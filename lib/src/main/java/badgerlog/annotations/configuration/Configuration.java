package badgerlog.annotations.configuration;

import badgerlog.annotations.StructType;
import badgerlog.conversion.UnitConverter;
import edu.wpi.first.units.Unit;
import edu.wpi.first.util.struct.Struct;
import lombok.Getter;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.HashMap;

/**
 * Configuration for BadgerLog entries. Used when creating entries and using mappings.
 */
@SuppressWarnings({"UnusedReturnValue", "InvalidBlockTag"})
@Getter
public class Configuration {
    /**
     * {@return the converters with their ids}
     */
    private final HashMap<String, UnitConverter<?>> converters = new HashMap<>();
    /**
     * {@return the key on NetworkTables}
     */
    private String key = null;
    /**
     * {@return the struct publishing option}
     */
    private StructType structType = null;
    /**
     * {@return whether to auto generate a struct from a record or enum}
     */
    private boolean autoGenerateStruct = false;
    /**
     * {@return the auto generated struct}
     */
    private Struct<?> autoGeneratedStruct = null;
    /**
     * {@return if the configuration is still valid}
     */
    private boolean isValidConfiguration = true;

    /**
     * {@return the converter associated with the specified id}
     *
     * @param id the converter's id
     * @param <T> the type of the converter
     */
    @SuppressWarnings("unchecked")
    // can guarantee that the resulting converter is used by the correct mapping type, since it is defined in the mapping 
    public <T extends Unit> UnitConverter<T> getConverter(String id) {
        return (UnitConverter<T>) converters.get(id);
    }

    /**
     * {@code id} defaults to {@code ""}
     *
     * @see #getConverter(String)
     */
    public <T extends Unit> UnitConverter<T> getDefaultConverter() {
        return getConverter("");
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param key the key to use on NetworkTables
     */
    public Configuration withKey(String key) {
        this.key = key;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param id the id of the converter
     * @param converter the converter to add
     */
    public Configuration withConverter(String id, UnitConverter<?> converter) {
        this.converters.put(id, converter);
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param structType the struct options to use for publishing
     */
    public Configuration withStructType(StructType structType) {
        this.structType = structType;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param autoGenerateStruct whether a struct should be auto generated for the type
     */
    public Configuration withAutoGenerateStruct(boolean autoGenerateStruct) {
        this.autoGenerateStruct = autoGenerateStruct;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param generatedStruct the struct generated for the type
     */
    public Configuration withGeneratedStruct(Struct<?> generatedStruct) {
        this.autoGeneratedStruct = generatedStruct;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     * Makes this configuration object invalid for entries created from fields
     */
    public Configuration makeInvalid() {
        this.isValidConfiguration = false;
        return this;
    }

    /**
     * Creates a configuration object from field annotations using the annotation handlers.
     *
     * @param field the field to create the object from
     *
     * @return a configuration object from field annotations
     */
    public static Configuration createConfigurationFromFieldAnnotations(Field field) {
        Configuration config = new Configuration();
        Annotation[] annotations = field.getDeclaredAnnotations();
        for (Annotation annotation : annotations) {
            handleAnnotation(annotation, config);
        }
        return config;
    }

    @SuppressWarnings("unchecked") // Annotation must have a class of type T from type requirements
    private static <T extends Annotation> void handleAnnotation(T annotation, Configuration config) {
        if (!ConfigHandlerRegistry.hasValidHandler(annotation.annotationType())) {
            return;
        }
        ConfigHandlerRegistry.getHandler((Class<T>) annotation.annotationType()).process(annotation, config);
    }
}
