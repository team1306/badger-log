package badgerlog.annotations.configuration;

import badgerlog.annotations.StructType;
import badgerlog.conversion.UnitConverter;
import edu.wpi.first.units.Unit;
import edu.wpi.first.util.struct.Struct;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Member;
import java.util.HashMap;

/**
 * Configuration for BadgerLog entries. Used when creating entries and using mappings.
 */
@SuppressWarnings({"UnusedReturnValue", "InvalidBlockTag"})
public class Configuration {
    /**
     * {@return the converters with their ids}
     */
    private final HashMap<String, UnitConverter<?>> converters = new HashMap<>();
    
    private String key = null;
    private String table = null;
    private StructType structType = null;
    private boolean autoGenerateStruct = false;
    private Struct<?> autoGeneratedStruct = null;
    private boolean isValidConfiguration = true;

    /**
     * {@return the converter associated with the specified id}
     *
     * @param id the converter's id
     * @param <T> the type of the converter
     */
    @SuppressWarnings("unchecked")
    // can guarantee that the resulting converter is used by the correct mapping type, since it is defined in the mapping
    public <T extends Unit> UnitConverter<T> getConverter(String id) {
        return (UnitConverter<T>) converters.get(id);
    }

    /**
     * {@code id} defaults to a blank {@code String}
     *
     * @see #getConverter(String)
     */
    public <T extends Unit> UnitConverter<T> getDefaultConverter() {
        return getConverter("");
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param key the key to use on NetworkTables
     */
    public Configuration withKey(String key) {
        this.key = key;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param id the id of the converter
     * @param converter the converter to add
     */
    public Configuration withConverter(String id, UnitConverter<?> converter) {
        this.converters.put(id, converter);
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param structType the struct options to use for publishing
     */
    public Configuration withStructType(StructType structType) {
        this.structType = structType;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param autoGenerateStruct whether a struct should be auto generated for the type
     */
    public Configuration withAutoGenerateStruct(boolean autoGenerateStruct) {
        this.autoGenerateStruct = autoGenerateStruct;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param generatedStruct the struct generated for the type
     */
    public Configuration withGeneratedStruct(Struct<?> generatedStruct) {
        this.autoGeneratedStruct = generatedStruct;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     * Makes this configuration object invalid for entries created from fields
     */
    public Configuration makeInvalid() {
        this.isValidConfiguration = false;
        return this;
    }

    /**
     * {@return the configuration object for method chaining}
     *
     * @param table the table above the key on NetworkTables
     */
    public Configuration withTable(String table) {
        this.table = table;
        return this;
    }

    /**
     * Creates a new {@link Configuration} based on a {@link Member Member's} annotations and enclosing class
     *
     * @param element the element with possible annotations
     *
     * @return a new {@code Configuration} from annotation values
     *
     * @param <T> the {@code Member} and {@link AnnotatedElement} type
     */
    public static <T extends Member & AnnotatedElement> Configuration createConfigurationFromAnnotations(T element) {
        Configuration config = new Configuration();
        Annotation[] classAnnotations = element.getDeclaringClass().getAnnotations();
        for (Annotation annotation : classAnnotations) {
            handleAnnotation(annotation, config);
        }

        Annotation[] annotations = element.getDeclaredAnnotations();
        for (Annotation annotation : annotations) {
            handleAnnotation(annotation, config);
        }
        return config;
    }

    @SuppressWarnings("unchecked") // Annotation must have a class of type T from type requirements
    private static <T extends Annotation> void handleAnnotation(T annotation, Configuration config) {
        if (!ConfigHandlerRegistry.hasValidHandler(annotation.annotationType())) {
            return;
        }
        ConfigHandlerRegistry.getHandler((Class<T>) annotation.annotationType()).process(annotation, config);
    }

    /**
     * {@return the key on NetworkTables}
     */
    public String getKey(){
        return key;
    }

    /**
     * {@return the table on NetworkTables}
     */
    public String getTable(){
        return table;
    }

    /**
     * {@return the struct publishing option}
     */
    public StructType getStructType(){
        return structType;
    }

    /**
     * {@return whether to auto generate a struct from a record or enum}
     */
    public boolean isAutoGenerateStruct(){
        return autoGenerateStruct;
    }

    /**
     * {@return the auto generated struct}
     */
    public Struct<?> getAutoGeneratedStruct(){
        return autoGeneratedStruct;
    }

    /**
     * {@return if the configuration is still valid}
     */
    public boolean isValidConfiguration(){
        return isValidConfiguration;
    }
}
