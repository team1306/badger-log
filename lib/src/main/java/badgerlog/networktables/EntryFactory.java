package badgerlog.networktables;

import badgerlog.Dashboard;
import badgerlog.annotations.StructOptions;
import badgerlog.annotations.configuration.Configuration;
import edu.wpi.first.util.struct.Struct;
import edu.wpi.first.util.struct.StructFetcher;
import edu.wpi.first.util.struct.StructSerializable;

import java.util.Optional;

public final class EntryFactory {
    private EntryFactory() {
    }

    @SuppressWarnings("unchecked")
    public static <T> NTEntry<T> createNetworkTableEntryFromValue(String key, T value, Configuration config) {
        Class<T> valueTypeClass = (Class<T>) value.getClass();

        if (StructSerializable.class.isAssignableFrom(valueTypeClass)) {
            Optional<Struct<?>> structOptional = StructFetcher.fetchStructDynamic(valueTypeClass);
            if (structOptional.isPresent()) {

                Struct<T> struct = (Struct<T>) structOptional.get();
                StructOptions option = config.getStructOptions() == null ? Dashboard.config.getStructOptions() : config.getStructOptions();

                return switch (option) {
                    case STRUCT -> new StructValueEntry<>(key, struct, value);
                    case SUB_TABLE -> new SubtableEntry<>(key, struct, value);
                    case MAPPING -> new ValueEntry<>(key, valueTypeClass, value, config);
                };
            }
        }

        if (config.isAutoGenerateStruct()) {
            StructOptions option = config.getStructOptions() == null ? Dashboard.config.getStructOptions() : config.getStructOptions();
            Struct<T> generatedStruct = (Struct<T>) config.getAutoGeneratedStruct();

            if (generatedStruct != null) {
                return option == StructOptions.SUB_TABLE ? new SubtableEntry<>(key, generatedStruct, value) : new StructValueEntry<>(key, generatedStruct, value);
            }
        }

        return new ValueEntry<>(key, valueTypeClass, value, config);
    }
}
